
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title id="title"></title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1, p { text-align: center; }
    .input-container {
      text-align: center;
      margin-bottom: 20px;
    }
    .parts-input {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
    }
    .part-item { text-align: center; width: 80px; }
    .part-item img { width: 40px; height: 40px; }
    .part-item input[type="number"] { width: 50px; margin-top: 4px; }
    .chip-input {
      margin-top: 16px;
      text-align: center;
    }
    .chip-input img { vertical-align: middle; width: 30px; height: 30px; }
    #calculate-btn {
      margin-top: 16px;
      display: inline-block;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
    }
    #calculate-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      margin-right: 8px;
      vertical-align: text-bottom;
      border: 2px solid currentColor;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .results-area { margin-top: 30px; overflow-x: auto; }
    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;
      font-size: 14px;
    }
    thead th {
      border-bottom: 2px solid #333;
      padding: 6px;
      background: #f0f0f0;
      text-align: center;
      white-space: nowrap;
    }
    tbody td {
      border-bottom: 1px solid #ccc;
      padding: 4px 6px;
      text-align: center;
      white-space: nowrap;
    }
    .col-number { border-right: 2px solid #666; }
    .col-EDS-icon { border-right: 1px solid #999; }
    .col-EDS-chip { border-right: 1px solid #999; }
    .col-EDS-total { border-right: 1px solid #999; }
    .col-EDS-target { border-right: 2px solid #666; }
    .col-AM-icon { border-right: 1px solid #999; }
    .col-AM-chip { border-right: 1px solid #999; }
    .col-AM-total { border-right: 1px solid #999; }
    .col-AM-target { border-right: 2px solid #666; }
    .col-PD-icon { border-right: 1px solid #999; }
    .col-PD-chip { border-right: 1px solid #999; }
    .col-PD-total { border-right: 1px solid #999; }
    .col-PD-target { border-right: 2px solid #666; }
    .col-QN-icon { border-right: 1px solid #999; }
    .col-QN-chip { border-right: 1px solid #999; }
    .col-QN-total { border-right: 1px solid #999; }
    .col-QN-target { border-right: 1px solid #999; }
    .col-ER-icon { border-right: 1px solid #999; }
    .col-ER-chip { border-right: 1px solid #999; }
    .col-ER-total { border-right: 1px solid #999; }
    .col-ER-target { border-right: 2px solid #666; }
    .col-rem { }
    .col-EDS-icon img, .col-AM-icon img, .col-PD-icon img, .col-QN-icon img, .col-ER-icon img {
      width: 40px;
      height: 40px;
    }
    .unlock-note { font-size: 12px; color:#666; line-height:1.2; margin-top:2px; }
    @media (max-width: 600px) {
      .part-item img { width: 30px; height: 30px; }
      .part-item input[type="number"] { width: 40px; }
      .chip-input img { width: 24px; height: 24px; }
      #calculate-btn { font-size: 14px; padding: 6px 12px; }
      table { font-size: 12px; }
      thead th, tbody td { padding: 3px 4px; }
      .col-EDS-icon img, .col-AM-icon img, .col-PD-icon img, .col-QN-icon img, .col-ER-icon img { width: 28px; height: 28px; }
      .target-list { display:inline-block; white-space:normal; max-width:100vw; }
    }
    .target-list { display:inline-block; white-space:normal; max-width:580px; }
    footer {
      margin-top: 40px;
      text-align: center;
      color: #555;
      font-size: 14px;
    }
    .typed-parts-section { margin-bottom: 20px; }
    .typed-parts-table { overflow-x: auto; margin-top: 10px; }
    .typed-parts-table table { width: 100%; border-collapse: collapse; font-size: 14px; }
    .typed-parts-table th { background: #f0f0f0; padding: 8px 4px; border: 1px solid #ccc; text-align: center; }
    .typed-parts-table td { padding: 4px; border: 1px solid #ccc; text-align: center; }
    .typed-parts-table td.part-name { text-align: left; font-weight: bold; }
    .typed-parts-table input[type="number"] { width: 50px; padding: 4px; text-align: center; }
  </style>
</head>
<body>

  <h1 id="main-title"></h1>
  <p id="subtitle"></p>

  <div class="input-container">
    <!-- 新しい12種類のパーツ入力 -->
    <div class="typed-parts-section">
      <h3 id="typed-parts-title"></h3>
      <p id="typed-parts-desc" style="font-size: 14px; color: #666;"></p>
      <div id="typed-parts-table"></div>
    </div>

    <div class="chip-input" style="margin-top:20px;">
      <img src="chip_icon.png" alt="Chip" />
      <label id="label-chip"></label>
      <input type="number" id="input-chip" min="0" max="330" value="0" />
    </div>
    <button id="calculate-btn"></button>
  </div>

  <div id="results-area">
    <h2 id="result-list"></h2>
    <div id="results-container"></div>
    <button id="save-image-btn" style="margin-top:16px;"></button>
  </div>

  <footer>
    <script type='text/javascript' src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Support me on Ko-fi', '#72a4f2', 'V7V71KOLL8');kofiwidget2.draw();</script> 
    <br><br>
    <span id="footer-version">Version: v.4.1.0 &nbsp; / &nbsp; Created by Dox_Daffun<br>
    Special thanks to: Logi(@sonicmans) and YAMATO</span><br>
    <span id="footer-discord" style="color:#555;">
      Feedback or bug reports:&nbsp;
      <b>Discord: <a href="https://discord.com/" target="_blank">dox_daffun</a></b><br>
      If you’d like to use this code in your own project or tool, please let me know. Thank you!
    </span>
  </footer>

  <script>
    // --- 1. 多言語リソース定義 ---
    const resources = {
      ja: {
        title:        '共振最適化計算ツール',
        mainTitle:    '共振最適化計算ツール',
        subtitle:     '「マイパーツ」にあるレジェンド以上のテックパーツを種類ごとに入力し、「Calculate」を押すと、双生パーツの最適組合せを一覧で表示します。<br>※各パーツの種類ごとにランクと個数を入力してください。<br>※同じ種類のパーツのみが分解・再合成されます。<br>※「Target」とは、特に強力な効果が発動する共振エネルギーを指します。<br>※実際に装着しているパーツを除いた数を入力してください。',
        typedPartsTitle: 'パーツ入力',
        typedPartsDesc: '所持している各パーツの種類とランクを選択してください。',
        labelE:       'エターナル',
        labelL0:      'レジェンド',
        labelL1:      'レジェ＋１',
        labelL2:      'レジェ＋２',
        labelL3:      'レジェ＋３',
        labelL4:      'レジェ＋４',
        labelChip:    '共振チップ',
        btnCalculate: 'Calculate',
        btnCalculating: 'Calculating...',
        resultList:   '結果一覧',
        btnSaveImage: 'Save Result',
        partTypes: {
          Molotov: '火炎瓶',
          Laser: 'レーザー',
          Drone: 'ドローン',
          Soccer: 'サッカー',
          Lightning: '雷',
          Drill: 'ドリル',
          Durian: 'ドリアン',
          Boomerang: 'ブーメラン',
          Brick: 'レンガ',
          Guardian: 'ガーディアン',
          ForceField: 'フォースフィールド',
          Rocket: 'ロケット'
        },
        headers: {
          pattern: 'Pattern',
          EDS:   '<img src="EDS_icon.png" alt="EDS" width="40" height="40">',
          chip:    '必要チップ',
          energy:  '共振エネルギー',
          target:  'Target',
          AM:   '<img src="AM_icon.png" alt="AM" width="40" height="40">',
          PD: '<img src="PD_icon.png" alt="PD" width="40" height="40">',
          QN:  '<img src="QN_icon.png" alt="QN" width="40" height="40">',
          ER:  '<img src="ER_icon.png" alt="ER" width="40" height="40">',
          rem:     '余剰チップ',
        },
        unlock: { req: '必要' }
      },
      en: {
        title:        'Resonance Optimization Calculator',
        mainTitle:    'Resonance Optimization Calculator',
        subtitle:     'Enter your Tech Parts by type and rank, then press "Calculate" to see optimal Twin Part combinations.<br>*Enter rank and count for each part type you own.<br>*Only parts of the same type can be salvaged and re-merged.<br>*"Target" means a Resonance Energy that reaches a powerful effect.<br>*Do not include parts currently equipped.',
        typedPartsTitle: 'Part Input',
        typedPartsDesc: 'Select the type and rank of each part you own.',
        labelE:       'Eternal',
        labelL0:      'Legend',
        labelL1:      'Legend+1',
        labelL2:      'Legend+2',
        labelL3:      'Legend+3',
        labelL4:      'Legend+4',
        labelChip:    'Resonance Chip',
        btnCalculate: 'Calculate',
        btnCalculating: 'Calculating...',
        resultList:   'Results',
        btnSaveImage: 'Save Result',
        partTypes: {
          Molotov: 'Molotov',
          Laser: 'Laser',
          Drone: 'Drone',
          Soccer: 'Soccer',
          Lightning: 'Lightning',
          Drill: 'Drill',
          Durian: 'Durian',
          Boomerang: 'Boomerang',
          Brick: 'Brick',
          Guardian: 'Guardian',
          ForceField: 'Force Field',
          Rocket: 'Rocket'
        },
        headers: {
          pattern: 'Pattern',
          EDS:   '<img src="EDS_icon.png" alt="EDS" width="40" height="40">',
          chip:    'Chip Needed',
          energy:  'Resonance Energy',
          target:  'Target',
          AM:   '<img src="AM_icon.png" alt="AM" width="40" height="40">',
          PD: '<img src="PD_icon.png" alt="PD" width="40" height="40">',
          QN:  '<img src="QN_icon.png" alt="QN" width="40" height="40">',
          ER:  '<img src="ER_icon.png" alt="ER" width="40" height="40">',
          rem:     'Chip Left',
        },
        unlock: { req: 'Req' }
      },
      zh: {
        title:        '共振优化计算器',
        mainTitle:    '共振优化计算器',
        subtitle:     '按类型输入你拥有的科技零件，然后点击"计算"显示最优双生件组合。<br>*为每种零件类型输入等级和数量。<br>*只有相同类型的零件才能分解和再合成。<br>*"目标"是指能够激发强力效果的共振能量。<br>*请不要计入当前已装备的部件。',
        typedPartsTitle: '零件输入',
        typedPartsDesc: '选择你拥有的每个零件的类型和等级。',
        labelE:       '永恒',
        labelL0:      '传奇',
        labelL1:      '传奇+1',
        labelL2:      '传奇+2',
        labelL3:      '传奇+3',
        labelL4:      '传奇+4',
        labelChip:    '共振芯片',
        btnCalculate: '计算',
        btnCalculating: '计算中...',
        resultList:   '结果列表',
        btnSaveImage: '保存结果',
        partTypes: {
          Molotov: '燃烧瓶',
          Laser: '激光',
          Drone: '无人机',
          Soccer: '足球',
          Lightning: '闪电',
          Drill: '钻头',
          Durian: '榴莲',
          Boomerang: '回旋镖',
          Brick: '砖块',
          Guardian: '守护者',
          ForceField: '力场',
          Rocket: '火箭'
        },
        headers: {
          pattern: '组合',
          EDS:   '<img src="EDS_icon.png" alt="EDS" width="40" height="40">',
          chip:    '所需芯片',
          energy:  '共振能量',
          target:  '目标',
          AM:   '<img src="AM_icon.png" alt="AM" width="40" height="40">',
          PD: '<img src="PD_icon.png" alt="PD" width="40" height="40">',
          QN:  '<img src="QN_icon.png" alt="QN" width="40" height="40">',
          ER:  '<img src="ER_icon.png" alt="ER" width="40" height="40">',
          rem:     '剩余芯片',
        },
        unlock: { req: '需求' }
      },
      ko: {
        title:        '공진 최적화 계산기',
        mainTitle:    '공진 최적화 계산기',
        subtitle:     '보유한 테크 파츠를 유형별로 입력하고 "Calculate"를 누르면 최적 트윈 파츠 조합을 표시합니다.<br>*각 파츠 유형의 등급과 개수를 입력하세요.<br>*같은 유형의 파츠만 분해 및 재조합할 수 있습니다.<br>*"Target"는 강력한 효과가 발동되는 공진 에너지를 의미합니다.<br>*현재 장착 중인 파츠는 제외하고 입력하세요.',
        typedPartsTitle: '파츠 입력',
        typedPartsDesc: '보유한 각 파츠의 유형과 등급을 선택하세요.',
        labelE:       '이터널',
        labelL0:      '레전드',
        labelL1:      '레전드+1',
        labelL2:      '레전드+2',
        labelL3:      '레전드+3',
        labelL4:      '레전드+4',
        labelChip:    '공진 칩',
        btnCalculate: 'Calculate',
        btnCalculating: 'Calculating...',
        resultList:   '결과 목록',
        btnSaveImage: '결과 저장',
        partTypes: {
          Molotov: '화염병',
          Laser: '레이저',
          Drone: '드론',
          Soccer: '축구공',
          Lightning: '번개',
          Drill: '드릴',
          Durian: '두리안',
          Boomerang: '부메랑',
          Brick: '벽돌',
          Guardian: '가디언',
          ForceField: '포스필드',
          Rocket: '로켓'
        },
        headers: {
          pattern: 'Pattern',
          EDS:   '<img src="EDS_icon.png" alt="EDS" width="40" height="40">',
          chip:    '필요 칩',
          energy:  '공진 에너지',
          target:  'Target',
          AM:   '<img src="AM_icon.png" alt="AM" width="40" height="40">',
          PD: '<img src="PD_icon.png" alt="PD" width="40" height="40">',
          QN:  '<img src="QN_icon.png" alt="QN" width="40" height="40">',
          ER:  '<img src="ER_icon.png" alt="ER" width="40" height="40">',
          rem:     '남은 칩',
        },
        unlock: { req: 'Req' }
      }
    };

    // --- 2. パーツタイプ定義 ---
    const partTypes = [
      'Molotov', 'Laser', 'Drone', 'Soccer',
      'Lightning', 'Drill', 'Durian', 'Boomerang',
      'Brick', 'Guardian', 'ForceField', 'Rocket'
    ];
    const rankOrder = ['E', 'L0', 'L1', 'L2', 'L3', 'L4'];

    // --- 3. ブラウザ言語自動判別 ---
    function getBrowserLang() {
      const lang = navigator.language || navigator.userLanguage || 'en';
      if (lang.startsWith('ja')) return 'ja';
      if (lang.startsWith('zh')) return 'zh';
      if (lang.startsWith('ko')) return 'ko';
      return 'en'; // デフォルトは英語
    }

    // --- 4. UI生成関数 ---
    function generateTypedPartsTable() {
      const lang = getBrowserLang();
      const res = resources[lang];
      const tableContainer = document.getElementById('typed-parts-table');

      let html = '<table><thead><tr>';
      html += '<th>Part Type</th>';
      for (const rank of rankOrder) {
        html += `<th>${res['label' + rank.replace('+', '')]}</th>`;
      }
      html += '</tr></thead><tbody>';

      for (const partType of partTypes) {
        html += '<tr>';
        html += `<td class="part-name">${res.partTypes[partType]}</td>`;
        for (const rank of rankOrder) {
          const inputId = `typed-${partType}-${rank}`;
          html += `<td><input type="number" id="${inputId}" min="0" value="0" /></td>`;
        }
        html += '</tr>';
      }

      html += '</tbody></table>';
      tableContainer.innerHTML = html;
    }

    // --- 5. 多言語テキストを画面に反映 ---
    function updateTextsByLang() {
      const lang = getBrowserLang();
      const res = resources[lang];
      document.title                          = res.title;
      document.getElementById('main-title').innerHTML      = res.mainTitle;
      document.getElementById('subtitle').innerHTML        = res.subtitle;
      document.getElementById('typed-parts-title').innerHTML = res.typedPartsTitle;
      document.getElementById('typed-parts-desc').innerHTML = res.typedPartsDesc;
      document.getElementById('label-chip').innerHTML      = res.labelChip;
      document.getElementById('calculate-btn').innerHTML   = res.btnCalculate;
      document.getElementById('result-list').innerHTML     = res.resultList;
      document.getElementById('save-image-btn').innerHTML = res.btnSaveImage;

      // Regenerate typed parts table with correct language
      generateTypedPartsTable();
    }

    // --- 6. データ収集関数 ---
    function collectInventory() {
      const typedParts = [];

      // Collect typed parts from the table
      for (const partType of partTypes) {
        for (const rank of rankOrder) {
          const inputId = `typed-${partType}-${rank}`;
          const element = document.getElementById(inputId);
          if (element) {
            const count = parseInt(element.value) || 0;
            if (count > 0) {
              typedParts.push({
                type: partType,
                rank: rank,
                count: count
              });
            }
          }
        }
      }

      return { typed: typedParts };
    }

    // --- 7. ユニークパーツID生成関数 ---
    function createUniquePartId(type, rank) {
      return `${type}_${rank}`;
    }

    // --- 8. ユニークパーツの基本ランクを取得 ---
    function getBaseRank(uniqueId) {
      const parts = uniqueId.split('_');
      return parts[1]; // e.g., "Molotov_E" -> "E"
    }

    let lookupReadyPromise = null;
    // --- 8. ページロード時に適用 ---
    window.addEventListener('DOMContentLoaded', function() {
      updateTextsByLang();
      if (!lookupReadyPromise) {
        lookupReadyPromise = loadLookupTable()
          .then(() => initializeLookupCache())
          .catch(err => {
            console.error('Failed to initialize lookup cache', err);
            lookupCache = {};
          });
      }
      // チップ入力の復元
      const chipInput = document.getElementById('input-chip');
      const savedChip = localStorage.getItem('calc_input_chip');
      if (savedChip !== null) chipInput.value = savedChip;
      chipInput.addEventListener('input', e => {
        localStorage.setItem('calc_input_chip', e.target.value);
      });

      // 結果を画像として保存
    document.getElementById('save-image-btn').addEventListener('click', ()=>{
      const target = document.getElementById('results-container');
      const prevWidth = target.style.width;
      const prevOverflowX = target.style.overflowX;
      target.style.width = 'max-content';
      target.style.overflowX = 'visible';
      setTimeout(() => {
        html2canvas(target, {useCORS: true, allowTaint: false}).then(canvas => {
          // 元に戻す
          target.style.width = prevWidth;
          target.style.overflowX = prevOverflowX;
          // ダウンロード
          const link = document.createElement('a');
          link.download = 'results.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
        });
      }, 200);
    });
    // Constants
    const partValues = { E:1000, L0:300, L1:400, L2:550, L3:700, L4:850, Y:200 };
    const targets = [900,1200,1650,2100,2550,3000,4500,6000,7500,9000,10500,12000,13500,15000];
    const allowedChips = [0,1,2,4,6,9,12,16,20,25,30,36,42,48,54,60,66,72,78,84,90];
    const unitValue = { L0:1, L1:2, L2:3, L3:4, L4:5, E:7, Y:0 };
    const unitReqByChip = {
      0:0, 1:0, 2:0, 4:0, 6:0, 9:0, 12:0, 16:0, 20:0, 25:0, 30:0,
      36:1, 42:2, 48:3, 54:4, 60:5, 66:6, 72:7, 78:8, 84:9, 90:10
    };
    const l0ConversionValues = { L0:1, L1:2, L2:3, L3:4, L4:5 };
    const rankOrderAsc = ['L0','L1','L2','L3','L4'];
    function canUnlockMultiplier(parts, chip) {
      const req = unitReqByChip[chip] ?? 0;
      const supply = parts.reduce((s, p) => {
        // Handle unique part IDs (e.g., "Molotov_E" -> "E")
        let rank = p;
        if (p.includes('_')) {
          rank = getBaseRank(p);
        }
        return s + (unitValue[rank] || 0);
      }, 0);
      if (req === 0) return { ok: true, reqU: 0, supplyU: supply };
      return { ok: supply >= req, reqU: req, supplyU: supply };
    }
    let lookupTable = {};
    let lookupCache = {};

    // CSV Loading
    async function loadLookupTable() {
      const response = await fetch('Lookup_Table.csv');
      const csvText = await response.text();
      const lines = csvText.trim().split('\n');
      const header = lines[0].split(',').map(s => s.trim());
      const idxA = header.indexOf('Const1');
      const idxB = header.indexOf('Const2');
      const idxC = header.indexOf('Const3');
      const idxChip = header.indexOf('Chip');
      const idxTotal = header.indexOf('Total');
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(',').map(s => s.trim());
        const pA = cols[idxA], pB = cols[idxB], pC = cols[idxC];
        const chip = parseInt(cols[idxChip],10);
        const total = parseFloat(cols[idxTotal]);
        const key = [pA,pB,pC].sort().join('|');
        if (!lookupTable[key]) lookupTable[key] = {};
        lookupTable[key][chip] = total;
      }
    }
    
    function calculatePatternL0Equivalent(parts) {
      let eCount = 0;
      let l0Total = 0;
      for (const part of parts) {
        // Handle unique part IDs (e.g., "Molotov_E" -> "E")
        let rank = part;
        if (part.includes('_')) {
          rank = getBaseRank(part);
        }

        if (rank === 'E') {
          eCount++;
        } else if (l0ConversionValues[rank] !== undefined) {
          l0Total += l0ConversionValues[rank];
        }
      }
      return { E: eCount, L0: l0Total };
    }

    function initializeLookupCache() {
      lookupCache = {};
      for (const key of Object.keys(lookupTable)) {
        const patternParts = key.split('|');
        const { E, L0 } = calculatePatternL0Equivalent(patternParts);
        const cacheKey = `E${E}_L0${L0}`;
        if (!lookupCache[cacheKey]) lookupCache[cacheKey] = [];
        lookupCache[cacheKey].push(key);
      }
    }

    function convertToL0Equivalent(parts) {
      let totalL0 = 0;
      const counts = { L0: parts.L0 || 0, L1: parts.L1 || 0, L2: parts.L2 || 0, L3: parts.L3 || 0, L4: parts.L4 || 0 };
      for (const rank of rankOrderAsc) {
        totalL0 += (counts[rank] || 0) * (l0ConversionValues[rank] || 0);
      }
      let maxRank = 'L0';
      for (let i = rankOrderAsc.length - 1; i >= 0; i--) {
        const rank = rankOrderAsc[i];
        if ((counts[rank] || 0) > 0) {
          maxRank = rank;
          break;
        }
      }
      return {
        E: parts.E || 0,
        L0Total: totalL0,
        maxRank,
        maxCounts: counts
      };
    }

    function generateRecompositionPatterns(l0Total, constraints) {
      const MAX_RECOMPOSITION_PATTERNS = 1000;
      const activeRanks = rankOrderAsc.slice(0, rankOrderAsc.indexOf(constraints.maxRank || 'L0') + 1);
      const highRanks = activeRanks.slice().reverse().filter(rank => rank !== 'L0');
      const results = [];
      const seen = new Set();

      function dfs(idx, remaining, current) {
        if (results.length >= MAX_RECOMPOSITION_PATTERNS) return;
        if (idx === highRanks.length) {
          if (remaining < 0) return;
          const pattern = {};
          for (const rank of activeRanks) {
            pattern[rank] = current[rank] || 0;
          }
          pattern.L0 = remaining;
          const signature = activeRanks.map(rank => `${rank}:${pattern[rank]}`).join('|');
          if (!seen.has(signature)) {
            seen.add(signature);
            results.push(pattern);
          }
          return;
        }
        const rank = highRanks[idx];
        const value = l0ConversionValues[rank] || 0;
        const maxFromTotal = value === 0 ? 0 : Math.floor(remaining / value);
        let limit = maxFromTotal;
        if (rank === constraints.maxRank) {
          limit = Math.min(limit, constraints.maxCounts[rank] || 0);
        }
        for (let count = 0; count <= limit; count++) {
          current[rank] = count;
          dfs(idx + 1, remaining - count * value, current);
          if (results.length >= MAX_RECOMPOSITION_PATTERNS) break;
        }
        delete current[rank];
      }

      if (l0Total < 0) return [];
      dfs(0, l0Total, {});

      const originalSignature = activeRanks.map(rank => `${rank}:${constraints.maxCounts[rank] || 0}`).join('|');
      const originalTotal = activeRanks.reduce((sum, rank) => sum + (constraints.maxCounts[rank] || 0) * (l0ConversionValues[rank] || 0), 0);
      if (!seen.has(originalSignature) && originalTotal === l0Total) {
        if (results.length >= MAX_RECOMPOSITION_PATTERNS) results.pop();
        const originalPattern = {};
        for (const rank of activeRanks) {
          originalPattern[rank] = constraints.maxCounts[rank] || 0;
        }
        results.push(originalPattern);
      }
      return results;
    }

    // --- Typed Parts用のRecomposition Patterns生成（バランス調整版） ---
    function generateRecompositionPatternsForTypedParts(inventory) {
      // Group typed parts by type (only non-zero counts)
      const byType = {};
      for (const part of inventory.typed) {
        if (!byType[part.type]) {
          byType[part.type] = {};
        }
        byType[part.type][part.rank] = part.count;
      }

      const typeNames = Object.keys(byType);

      // If no typed parts, return empty pattern
      if (typeNames.length === 0) {
        return [{}];
      }

      // Generate recomposition patterns for each type (balanced)
      const patternsByType = {};
      for (const type in byType) {
        const partsOfType = byType[type];
        const converted = convertToL0Equivalent(partsOfType);
        const constraints = { maxRank: converted.maxRank, maxCounts: converted.maxCounts };

        // Generate patterns - keep more for better accuracy
        let recompPatterns = generateRecompositionPatterns(converted.L0Total, constraints);

        // Balanced reduction: keep enough patterns for diversity
        // Prioritize: original pattern + variations with high-rank parts
        const MAX_PATTERNS_PER_TYPE = 20;  // Increased for better coverage
        patternsByType[type] = recompPatterns.slice(0, MAX_PATTERNS_PER_TYPE);
      }

      // Balance between performance and accuracy
      const MAX_TOTAL_PATTERNS = 200;  // Increased for better coverage

      // Generate combinations iteratively with early stopping
      const unifiedPatterns = [];

      function generateCombinations(typeIndex, currentUnified) {
        if (unifiedPatterns.length >= MAX_TOTAL_PATTERNS) return;

        if (typeIndex >= typeNames.length) {
          unifiedPatterns.push({ ...currentUnified });
          return;
        }

        const type = typeNames[typeIndex];
        const patterns = patternsByType[type];

        for (const pattern of patterns) {
          if (unifiedPatterns.length >= MAX_TOTAL_PATTERNS) break;

          const newUnified = { ...currentUnified };
          for (const rank in pattern) {
            if (pattern[rank] > 0) {
              const uniqueId = createUniquePartId(type, rank);
              newUnified[uniqueId] = pattern[rank];
            }
          }

          generateCombinations(typeIndex + 1, newUnified);
        }
      }

      generateCombinations(0, {});

      return unifiedPatterns.length > 0 ? unifiedPatterns : [{}];
    }

    function findMatchingPatterns(availableParts) {
      if (!availableParts) return [];
      const matches = new Set();
      const maxE = availableParts.E || 0;
      const maxL0 = availableParts.L0Total || 0;
      for (let e = 0; e <= maxE; e++) {
        for (let l0 = 0; l0 <= maxL0; l0++) {
          const cacheKey = `E${e}_L0${l0}`;
          if (lookupCache[cacheKey]) {
            for (const patternKey of lookupCache[cacheKey]) {
              matches.add(patternKey);
            }
          }
        }
      }
      return Array.from(matches);
    }

    const TARGET_KEY_LIMIT = 1000;

    function countUsedParts(pattern) {
      let count = 0;
      ['EDS', 'AM', 'PD', 'QN', 'ER'].forEach(slot => {
        const parts = pattern[`parts${slot}`] || [];
        parts.forEach(part => {
          if (part !== 'E') count++;
        });
      });
      return count;
    }

    function shouldSkipTargets(newTargets, existingResults) {
      return existingResults.some(existing =>
        existing.targetEDS >= newTargets.EDS &&
        existing.targetAM >= newTargets.AM &&
        existing.targetPD >= newTargets.PD &&
        existing.targetQN >= newTargets.QN &&
        existing.targetER >= newTargets.ER &&
        (
          existing.targetEDS > newTargets.EDS ||
          existing.targetAM > newTargets.AM ||
          existing.targetPD > newTargets.PD ||
          existing.targetQN > newTargets.QN ||
          existing.targetER > newTargets.ER
        )
      );
    }

    function buildTargetKey(targets) {
      return `${targets.EDS}_${targets.AM}_${targets.PD}_${targets.QN}_${targets.ER}`;
    }

    function buildTargetKeyFromCombo(combo) {
      return buildTargetKey({
        EDS: combo.targetEDS,
        AM: combo.targetAM,
        PD: combo.targetPD,
        QN: combo.targetQN,
        ER: combo.targetER
      });
    }

    function dominates(a, b) {
      const betterOrEqual =
        a.targetEDS >= b.targetEDS &&
        a.targetAM >= b.targetAM &&
        a.targetPD >= b.targetPD &&
        a.targetQN >= b.targetQN &&
        a.targetER >= b.targetER;
      if (!betterOrEqual) return false;
      return (
        a.targetEDS > b.targetEDS ||
        a.targetAM > b.targetAM ||
        a.targetPD > b.targetPD ||
        a.targetQN > b.targetQN ||
        a.targetER > b.targetER
      );
    }

    function createResultAggregator() {
      const seenTargets = new Map();
      const keyQueue = [];
      const results = [];
      // タイブレーク優先：分解回数 → 余り → EDS → AM → PD → QN → ER
      function better(a, b) {
        if (a.splitCount !== b.splitCount) return a.splitCount < b.splitCount;
        if (a.chipRemainder !== b.chipRemainder) return a.chipRemainder < b.chipRemainder;
        if (a.targetEDS !== b.targetEDS) return a.targetEDS > b.targetEDS;
        if (a.targetAM  !== b.targetAM ) return a.targetAM  > b.targetAM;
        if (a.targetPD  !== b.targetPD ) return a.targetPD  > b.targetPD;
        if (a.targetQN  !== b.targetQN ) return a.targetQN  > b.targetQN;
        if (a.targetER  !== b.targetER ) return a.targetER  > b.targetER;
        return false;
      }

      function removeKeyFromQueue(key) {
        for (let i = keyQueue.length - 1; i >= 0; i--) {
          if (keyQueue[i] === key) keyQueue.splice(i, 1);
        }
      }

      function removeEntryByKey(key) {
        const existing = seenTargets.get(key);
        if (!existing) return;
        const idx = results.indexOf(existing);
        if (idx !== -1) results.splice(idx, 1);
        seenTargets.delete(key);
        removeKeyFromQueue(key);
      }

      function pruneIfNecessary() {
        while (seenTargets.size > TARGET_KEY_LIMIT) {
          const oldestKey = keyQueue.shift();
          if (!oldestKey) break;
          removeEntryByKey(oldestKey);
        }
      }

      function pruneDominatedBy(combo) {
        for (let i = results.length - 1; i >= 0; i--) {
          const candidate = results[i];
          if (candidate === combo) continue;
          if (dominates(combo, candidate)) {
            const key = buildTargetKeyFromCombo(candidate);
            results.splice(i, 1);
            seenTargets.delete(key);
            removeKeyFromQueue(key);
          }
        }
      }

      function consider(combo) {
        // ① EDS ≥ AM ≥ PD ≥ QN ≥ ER は上流で判定済みだが、念のため弾く
        if (!(combo.targetEDS >= combo.targetAM &&
              combo.targetAM  >= combo.targetPD &&
              combo.targetPD  >= combo.targetQN &&
              combo.targetQN  >= combo.targetER)) return false;

        const targets = {
          EDS: combo.targetEDS,
          AM: combo.targetAM,
          PD: combo.targetPD,
          QN: combo.targetQN,
          ER: combo.targetER
        };
        const targetKey = buildTargetKey(targets);

        // ② 同一Target組み合わせは代表1件のみ（分解回数→余り→EDS→AM→PD→QN→ER の優先で置換）
        if (seenTargets.has(targetKey)) {
          const existing = seenTargets.get(targetKey);
          if (!better(combo, existing)) return false;     // 既存の方が優先
          const idx = results.indexOf(existing);
          if (idx !== -1) results[idx] = combo; else results.push(combo);
          seenTargets.set(targetKey, combo);
          removeKeyFromQueue(targetKey);
          keyQueue.push(targetKey);
          pruneIfNecessary();
          return true;
        }

        // ③ 明らかに劣っている（既存のいずれかに完全支配される）なら捨てる
        for (const cand of results) {
          if (dominates(cand, combo)) return false;
        }

        // 受理して、逆に既存の劣後（支配される）を削除
        results.push(combo);
        seenTargets.set(targetKey, combo);
        keyQueue.push(targetKey);
        for (let i = results.length - 2; i >= 0; i--) {
          const cand = results[i];
          if (dominates(combo, cand)) {
            const k = buildTargetKeyFromCombo(cand);
            results.splice(i, 1);
            if (seenTargets.get(k) === cand) {
              seenTargets.delete(k);
              removeKeyFromQueue(k);
            }
          }
        }
        pruneIfNecessary();
        return true;
      }

      return {
        consider,
        getResults: () => results.slice()
      };
    }

    function sortByTargetPriority(results) {
      return results.sort((a, b) => {
        // 1) EDS→AM→PD→QN→ER の降順
        if (b.targetEDS !== a.targetEDS) return b.targetEDS - a.targetEDS;
        if (b.targetAM  !== a.targetAM ) return b.targetAM  - a.targetAM;
        if (b.targetPD  !== a.targetPD ) return b.targetPD  - a.targetPD;
        if (b.targetQN  !== a.targetQN ) return b.targetQN  - a.targetQN;
        if (b.targetER  !== a.targetER ) return b.targetER  - a.targetER;
        // 2) 完全同点のときのみ、分解回数→余り で安定化
        if (a.splitCount !== b.splitCount) return a.splitCount - b.splitCount;
        if (a.chipRemainder !== b.chipRemainder) return a.chipRemainder - b.chipRemainder;
        return 0;
      });
    }

    function filterPriorityConsistent(results) {
      if (!results || results.length === 0) return [];
      const filtered = [];
      let lastKept = null;
      for (const combo of results) {
        if (!lastKept) {
          filtered.push(combo);
          lastKept = combo;
          continue;
        }
        if (
          combo.targetEDS <= lastKept.targetEDS &&
          combo.targetAM <= lastKept.targetAM &&
          combo.targetPD <= lastKept.targetPD &&
          combo.targetQN <= lastKept.targetQN &&
          combo.targetER <= lastKept.targetER
        ) {
          filtered.push(combo);
          lastKept = combo;
        }
      }
      return filtered;
    }

    document.getElementById('calculate-btn').addEventListener('click', () => {
      const btn = document.getElementById('calculate-btn');
      const lang = getBrowserLang();
      btn.disabled = true;
      btn.innerHTML = `<span class="spinner"></span>${resources[lang].btnCalculating}`;
      setTimeout(async () => {
        if (!lookupReadyPromise) {
          lookupReadyPromise = loadLookupTable()
            .then(() => initializeLookupCache())
            .catch(err => {
              console.error('Failed to initialize lookup cache', err);
              lookupCache = {};
            });
        }
        try {
          await lookupReadyPromise;
        } catch (error) {
          console.error('Lookup table loading failed', error);
        }

        // Collect inventory (typed + untyped parts)
        const inventory = collectInventory();
        const C_total = parseInt(document.getElementById('input-chip').value) || 0;

        // Generate recomposition patterns for typed parts and combine with untyped
        const unifiedPatterns = generateRecompositionPatternsForTypedParts(inventory);

        // For backward compatibility with lookup table matching, we can skip it for now
        // since typed parts won't be in the lookup table
        const matchingKeySet = new Set();

        const seenPatterns = new Set();
        const aggregator = createResultAggregator();

        for (const pattern of unifiedPatterns) {
          // Generate signature for deduplication
          const parts = Object.keys(pattern).sort();
          const signature = parts.map(p => `${p}:${pattern[p]}`).join('|');
          if (seenPatterns.has(signature)) continue;
          seenPatterns.add(signature);

          computeOverOrEqualNine(pattern, C_total, matchingKeySet, aggregator);
        }
        const results = sortByTargetPriority(aggregator.getResults());
        // clear caches to avoid memory growth between calculations
        for (const k in comboCache) delete comboCache[k];
        for (const k in totalCache) delete totalCache[k];
        renderResults(results);
        btn.disabled = false;
        btn.innerHTML = resources[lang].btnCalculate;
      }, 10);
    });

    // Utility functions for combo generation
    const partOrder = ['E','L4','L3','L2','L1','L0','Y'];

    // --- 10. ユニークパーツ用の組み合わせ列挙関数（最適化版） ---
    function enumerateCombosFromInventory(inventory, size) {
      // Get all available unique part types from inventory
      const availableParts = [];
      for (const uniqueId in inventory) {
        if (inventory[uniqueId] > 0) {
          availableParts.push(uniqueId);
        }
      }

      // Sort parts by priority (E > L4 > L3 > L2 > L1 > L0)
      // This ensures high-rank parts are tried first
      availableParts.sort((a, b) => {
        const rankA = getBaseRank(a);
        const rankB = getBaseRank(b);
        const priorityOrder = ['E', 'L4', 'L3', 'L2', 'L1', 'L0', 'Y'];
        const idxA = priorityOrder.indexOf(rankA);
        const idxB = priorityOrder.indexOf(rankB);
        if (idxA !== idxB) return idxA - idxB;
        return a.localeCompare(b);
      });

      // Add 'Y' (dummy/empty part)
      availableParts.push('Y');

      const results = [];
      const n = availableParts.length;
      const MAX_COMBOS = 2000; // Increased limit for better coverage

      // Generate combinations with high-rank parts prioritized
      // Use stratified sampling: ensure we try high-rank combinations first
      for (let i = 0; i < n && results.length < MAX_COMBOS; i++) {
        for (let j = i; j < n && results.length < MAX_COMBOS; j++) {
          for (let k = j; k < n && results.length < MAX_COMBOS; k++) {
            const combo = [availableParts[i], availableParts[j], availableParts[k]];
            const counts = {};
            for (const p of combo) counts[p] = (counts[p] || 0) + 1;

            let ok = true;
            for (const p in counts) {
              if (p !== 'Y' && (inventory[p] || 0) < counts[p]) {
                ok = false;
                break;
              }
            }
            if (ok) results.push(combo);
          }
        }
      }

      if (results.length === 0) {
        let fill = [];
        let remain = size;
        for (const p of availableParts) {
          const available = inventory[p] || 0;
          for (let i = 0; i < available && remain > 0; i++, remain--) {
            fill.push(p);
          }
        }
        while (fill.length < size) fill.push('Y');
        return [fill];
      }

      return results;
    }

    // cache for combinations from the same inventory state
    const comboCache = {};
    function getCombosMemo(inv, size) {
      // Generate key from all available parts in inventory
      const parts = Object.keys(inv).sort();
      const key = parts.map(p => `${p}:${inv[p]}`).join(',');
      if (!comboCache[key]) {
        comboCache[key] = enumerateCombosFromInventory(inv, size);
      }
      return comboCache[key];
    }
    // generate chip splits lazily to avoid large intermediate arrays
    function* enumerateChipSplits(C_total) {
      const baseRates = [
        [0.30, 0.40], // ドリル
        [0.15, 0.25], // 雷
        [0.09, 0.25], // サッカー
        [0.05, 0.20]  // レーザー
      ];
      const FEW_CHIP_LIMIT = 20, MANY_CHIP_LIMIT = 220;
      const pruning = Math.max(0, Math.min(1, (C_total - FEW_CHIP_LIMIT) / (MANY_CHIP_LIMIT - FEW_CHIP_LIMIT)));

      const minC = Math.floor(C_total * (0.01 + 0.12 * pruning));
      const maxC = Math.min(90, Math.floor(C_total * (0.97 - 0.42 * pruning)));

      const rates = baseRates.map(([start, width]) => start + width * pruning);
      const maxRem = Math.floor(70 - 49 * pruning);
      const maxCount = Math.floor(30000 - 15000 * pruning);
      const maxDiff = Math.floor(55 - 35 * pruning);

      const pool = allowedChips.filter(c => c >= minC && c <= maxC).reverse();
      let count = 0;

      for (let d of pool) {
        for (let r of pool) {
          if (r > d) continue;
          if (r < d * rates[0]) break;

          for (let l of pool) {
            if (l > r) continue;
            if (l < d * rates[1]) break;

            for (let s of pool) {
              if (s > l) continue;
              if (s < d * rates[2]) break;

              for (let e of pool) {
                if (e > s) continue;
                if (e < d * rates[3]) break;
                const sum = d + r + l + s + e;
                if (sum > C_total) break;

                const rem = C_total - sum;
                if (rem > maxRem) continue;
                if (d - e > maxDiff) continue;

                yield { cD: d, cR: r, cL: l, cS: s, cER: e, rem: rem };
                if (++count >= maxCount) return;
              }
            }
          }
        }
      }
    }
    function computeTargetFromTotal(total) {
      let t = 0;
      for (let val of targets) {
        if (total >= val) t = val; else break;
      }
      return t;
    }
    function calculateOnTheFly(comboParts, chip) {
      let baseSum = 0;
      for (let p of comboParts) {
        // Handle unique part IDs (e.g., "Molotov_E" -> "E")
        let rank = p;
        if (p.includes('_')) {
          rank = getBaseRank(p);
        }
        baseSum += partValues[rank] || 0;
      }
      const multMap = {
        0:1.0, 1:1.2, 2:1.4, 4:1.6, 6:1.8,
        9:2.0,12:2.2,16:2.4,20:2.6,25:2.8,
        30:3.0,36:3.2,42:3.4,48:3.6,54:3.8,
        60:4.0,66:4.2,72:4.4,78:4.6,84:4.8,
        90:5.0
      };
      const m = multMap[chip] !== undefined ? multMap[chip] : 1.0;
      return baseSum * m;
    }
    const totalCache = {};
    function getTotal(parts, chip) {
      const sortedKey = parts.slice().sort().join('|');
      const cacheKey = `${sortedKey}|${chip}`;
      if (totalCache[cacheKey] !== undefined) return totalCache[cacheKey];
      let val;
      const { E, L0 } = calculatePatternL0Equivalent(parts);
      const lookupCandidates = lookupCache[`E${E}_L0${L0}`] || [];
      for (const candidateKey of lookupCandidates) {
        if (candidateKey === sortedKey) {
          const entry = lookupTable[candidateKey];
          if (entry && entry[chip] !== undefined) {
            val = entry[chip];
            break;
          }
        }
      }
      if (val === undefined) {
        if (lookupTable[sortedKey] && lookupTable[sortedKey][chip] !== undefined) {
          val = lookupTable[sortedKey][chip];
        } else {
          val = calculateOnTheFly(parts, chip);
        }
      }
      totalCache[cacheKey] = val;
      return val;
    }

    // 分解回数＝必要パーツが手持ちより不足した個数の合計（E/Yは除外）
    function calcSplitCount(invOriginal, solItems) {
      const used = {};
      for (const d of solItems) {
        for (const p of d.parts) {
          used[p] = (used[p] || 0) + 1;
        }
      }

      let split = 0;
      // For each unique part ID used, check if we have enough
      for (const uniqueId in used) {
        if (uniqueId === 'Y') continue; // Skip dummy parts

        const rank = uniqueId.includes('_') ? getBaseRank(uniqueId) : uniqueId;
        if (rank === 'E') continue; // Skip E parts

        const have = invOriginal[uniqueId] || 0;
        const need = used[uniqueId] || 0;
        if (need > have) {
          split += (need - have);
        }
      }

      return split;
    }

    function computeOverOrEqualNine(inv, C_total, matchingPatterns, aggregator) {
      const invKey = (inventory) => {
        const parts = Object.keys(inventory).sort();
        return parts.map(p => `${p}:${inventory[p]}`).join(',');
      };
      const patternSet = matchingPatterns instanceof Set
        ? matchingPatterns
        : (Array.isArray(matchingPatterns) ? new Set(matchingPatterns) : null);

      function search(idx, inventory, chips, dpMemo) {
        const key = idx + '|' + invKey(inventory) + '|' + chips.slice(idx).join(',');
        if (dpMemo.has(key)) return dpMemo.get(key);
        if (idx === chips.length) return [[]];
        const combos = getCombosMemo(inventory, 3);
        let res = [];
        const MAX_RESULTS = 400;  // Increased for better coverage
        for (let parts of combos) {
          const sortedKey = parts.slice().sort().join('|');
          if (patternSet && patternSet.size > 0) {
            const hasLookupEntry = !!lookupTable[sortedKey];
            if (hasLookupEntry && !patternSet.has(sortedKey)) continue;
          }
          if (res.length >= MAX_RESULTS) break;
          const gate = canUnlockMultiplier(parts, chips[idx]);
          if (!gate.ok) continue;
          const total = getTotal(parts, chips[idx]);
          const nextInv = { ...inventory };
          for (const p of parts) nextInv[p]--;
          const tails = search(idx + 1, nextInv, chips, dpMemo);
          for (let t of tails) {
            if (res.length >= MAX_RESULTS) break;
            res.push([{ parts, chip: chips[idx], total, gate }, ...t]);
          }
        }
        dpMemo.set(key, res);
        return res;
      }

      for (let { cD, cR, cL, cS, cER, rem } of enumerateChipSplits(C_total)) {
        const dpMemo = new Map();
        const solutions = search(0, { ...inv }, [cD, cR, cL, cS, cER], dpMemo);
        const limited = solutions.slice(0, 1000);  // Increased for better coverage
        for (let sol of limited) {
          const [d, r, l, s, e] = sol;
          // 目標値を算出
          const tEDS = computeTargetFromTotal(d.total);
          const tAM  = computeTargetFromTotal(r.total);
          const tPD  = computeTargetFromTotal(l.total);
          const tQN  = computeTargetFromTotal(s.total);
          const tER  = computeTargetFromTotal(e.total);
          // 順序条件：EDS ≥ AM ≥ PD ≥ QN ≥ ER
          if (!(tEDS >= tAM && tAM >= tPD && tPD >= tQN && tQN >= tER)) continue;
          // 分解回数（元の手持ち inv を基準）
          const splitCount = calcSplitCount(inv, [d,r,l,s,e]);
          const combo = {
            partsEDS: d.parts.slice(),
            chipEDS: d.chip,
            totalEDS: d.total,
            targetEDS: tEDS,
            partsAM: r.parts.slice(),
            chipAM: r.chip,
            totalAM: r.total,
            targetAM: tAM,
            partsPD: l.parts.slice(),
            chipPD: l.chip,
            totalPD: l.total,
            targetPD: tPD,
            partsQN: s.parts.slice(),
            chipQN: s.chip,
            totalQN: s.total,
            targetQN: tQN,
            partsER: e.parts.slice(),
            chipER: e.chip,
            totalER: e.total,
            targetER: tER,
            chipRemainder: rem,
            unlockD: d.gate,
            unlockR: r.gate,
            unlockL: l.gate,
            unlockS: s.gate,
            unlockE: e.gate,
            splitCount
          };
          if (aggregator && typeof aggregator.consider === 'function') {
            aggregator.consider(combo);
          }
        }
      }
    }

    function renderResults(results) {
      const container = document.getElementById('results-container');
      container.innerHTML = '';
      if (!results || results.length === 0) {
        container.innerHTML = '<p>No valid combination found.</p>';
        return;
      }
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const lang = getBrowserLang();
      const res = resources[lang] || resources['ja'];
      const h = res.headers;
      const i18nReq = res.unlock ? res.unlock.req : 'Req';
      const legendLabel = res.labelL0;

      const headers = [
        h.pattern,
        h.EDS, h.chip, h.energy, h.target,
        h.AM, h.chip, h.energy, h.target,
        h.PD, h.chip, h.energy, h.target,
        h.QN, h.chip, h.energy, h.target,
        h.ER, h.chip, h.energy, h.target,
        h.rem
      ];
      const thClasses = [
        'col-number','col-EDS-icon','col-EDS-chip','col-EDS-total','col-EDS-target',
        'col-AM-icon','col-AM-chip','col-AM-total','col-AM-target',
        'col-PD-icon','col-PD-chip','col-PD-total','col-PD-target',
        'col-QN-icon','col-QN-chip','col-QN-total','col-QN-target',
        'col-ER-icon','col-ER-chip','col-ER-total','col-ER-target',
        'col-rem'
      ];
      for (let i = 0; i < headers.length; i++) {
        const th = document.createElement('th');
        th.innerHTML = headers[i];
        th.className = thClasses[i];
        headerRow.appendChild(th);
      }
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for (let idx = 0; idx < results.length; idx++) {
        const item = results[idx];
        const tr = document.createElement('tr');
        // No.
        const tdNum = document.createElement('td');
        tdNum.innerHTML = (idx + 1).toString();
        tdNum.className = 'col-number';
        tr.appendChild(tdNum);
        // EDS icons
        const tdDicon = document.createElement('td');
        tdDicon.className = 'col-EDS-icon';
        tdDicon.innerHTML = item.partsEDS.map(p => {
          const displayRank = p.includes('_') ? getBaseRank(p) : p;
          return `<img src="${displayRank}.png" alt="${p}" width="40" height="40">`;
        }).join('&nbsp;');
        tr.appendChild(tdDicon);
        // EDS Chip
        const tdDchip = document.createElement('td');
        const noteD = item.unlockD.reqU > 0 ? `<div class="unlock-note">${i18nReq} ${legendLabel} ${item.unlockD.reqU}</div>` : '';
        tdDchip.innerHTML = `${item.chipEDS}${noteD}`;
        tdDchip.className = 'col-EDS-chip';
        tr.appendChild(tdDchip);
        // EDS Total
        const tdDtotal = document.createElement('td');
        tdDtotal.innerHTML = item.totalEDS.toFixed(0);
        tdDtotal.className = 'col-EDS-total';
        tr.appendChild(tdDtotal);
        // EDS Target
        const tdDtarget = document.createElement('td');
        tdDtarget.innerHTML = item.targetEDS;
        tdDtarget.className = 'col-EDS-target';
        tr.appendChild(tdDtarget);

        // AM icons
        const tdRicon = document.createElement('td');
        tdRicon.className = 'col-AM-icon';
        tdRicon.innerHTML = item.partsAM.map(p => {
          const displayRank = p.includes('_') ? getBaseRank(p) : p;
          return `<img src="${displayRank}.png" alt="${p}" width="40" height="40">`;
        }).join('&nbsp;');
        tr.appendChild(tdRicon);
        // AM Chip
        const tdRchip = document.createElement('td');
        const noteR = item.unlockR.reqU > 0 ? `<div class="unlock-note">${i18nReq} ${legendLabel} ${item.unlockR.reqU}</div>` : '';
        tdRchip.innerHTML = `${item.chipAM}${noteR}`;
        tdRchip.className = 'col-AM-chip';
        tr.appendChild(tdRchip);
        // AM Total
        const tdRtotal = document.createElement('td');
        tdRtotal.innerHTML = item.totalAM.toFixed(0);
        tdRtotal.className = 'col-AM-total';
        tr.appendChild(tdRtotal);
        // AM Target
        const tdRtarget = document.createElement('td');
        tdRtarget.innerHTML = item.targetAM;
        tdRtarget.className = 'col-AM-target';
        tr.appendChild(tdRtarget);

        // PD icons
        const tdLicon = document.createElement('td');
        tdLicon.className = 'col-PD-icon';
        tdLicon.innerHTML = item.partsPD.map(p => {
          const displayRank = p.includes('_') ? getBaseRank(p) : p;
          return `<img src="${displayRank}.png" alt="${p}" width="40" height="40">`;
        }).join('&nbsp;');
        tr.appendChild(tdLicon);
        // PD Chip
        const tdLchip = document.createElement('td');
        const noteL = item.unlockL.reqU > 0 ? `<div class="unlock-note">${i18nReq} ${legendLabel} ${item.unlockL.reqU}</div>` : '';
        tdLchip.innerHTML = `${item.chipPD}${noteL}`;
        tdLchip.className = 'col-PD-chip';
        tr.appendChild(tdLchip);
        // PD Total
        const tdLtotal = document.createElement('td');
        tdLtotal.innerHTML = item.totalPD.toFixed(0);
        tdLtotal.className = 'col-PD-total';
        tr.appendChild(tdLtotal);
        // PD Target
        const tdLtarget = document.createElement('td');
        tdLtarget.innerHTML = item.targetPD;
        tdLtarget.className = 'col-PD-target';
        tr.appendChild(tdLtarget);

        // QN icons
        const tdSicon = document.createElement('td');
        tdSicon.className = 'col-QN-icon';
        tdSicon.innerHTML = item.partsQN.map(p => {
          const displayRank = p.includes('_') ? getBaseRank(p) : p;
          return `<img src="${displayRank}.png" alt="${p}" width="40" height="40">`;
        }).join('&nbsp;');
        tr.appendChild(tdSicon);
        // QN Chip
        const tdSchip = document.createElement('td');
        const noteS = item.unlockS.reqU > 0 ? `<div class="unlock-note">${i18nReq} ${legendLabel} ${item.unlockS.reqU}</div>` : '';
        tdSchip.innerHTML = `${item.chipQN}${noteS}`;
        tdSchip.className = 'col-QN-chip';
        tr.appendChild(tdSchip);
        // QN Total
        const tdStotal = document.createElement('td');
        tdStotal.innerHTML = item.totalQN.toFixed(0);
        tdStotal.className = 'col-QN-total';
        tr.appendChild(tdStotal);
        // QN Target
        const tdStarget = document.createElement('td');
        tdStarget.innerHTML = item.targetQN;
        tdStarget.className = 'col-QN-target';
        tr.appendChild(tdStarget);

        // ER icons
        const tdEicon = document.createElement('td');
        tdEicon.className = 'col-ER-icon';
        tdEicon.innerHTML = item.partsER.map(p => {
          const displayRank = p.includes('_') ? getBaseRank(p) : p;
          return `<img src="${displayRank}.png" alt="${p}" width="40" height="40">`;
        }).join('&nbsp;');
        tr.appendChild(tdEicon);
        // ER Chip
        const tdEchip = document.createElement('td');
        const noteE = item.unlockE.reqU > 0 ? `<div class="unlock-note">${i18nReq} ${legendLabel} ${item.unlockE.reqU}</div>` : '';
        tdEchip.innerHTML = `${item.chipER}${noteE}`;
        tdEchip.className = 'col-ER-chip';
        tr.appendChild(tdEchip);
        // ER Total
        const tdEtotal = document.createElement('td');
        tdEtotal.innerHTML = item.totalER.toFixed(0);
        tdEtotal.className = 'col-ER-total';
        tr.appendChild(tdEtotal);
        // ER Target
        const tdEtarget = document.createElement('td');
        tdEtarget.innerHTML = item.targetER;
        tdEtarget.className = 'col-ER-target';
        tr.appendChild(tdEtarget);
        
        // Rem. Chip
        const tdRem = document.createElement('td');
        tdRem.innerHTML = item.chipRemainder;
        tdRem.className = 'col-rem';
        tr.appendChild(tdRem);

        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      container.appendChild(table);
    }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  

</body>
</html>
