<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>パーツ＋チップ最適化計算ツール</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1 { text-align: center; }
    .parts-input { display: flex; flex-wrap: wrap; gap: 12px; }
    .part-item { text-align: center; width: 100px; }
    .part-item img { width: 60px; height: 60px; }
    .part-item input[type="number"] { width: 60px; margin-top: 4px; }
    .chip-input { margin-top: 16px; text-align: center; }
    .chip-input img { vertical-align: middle; width: 40px; height: 40px; }
    #calculate-btn { margin-top: 20px; display: block; padding: 8px 16px; font-size: 16px; }
    .results-area { margin-top: 30px; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: center; }
  </style>
</head>
<body>

  <h1>パーツ＋チップ 最適化計算ツール</h1>
  <p>
    以下に所持パーツの枚数と Chip の数を入力し、「Calculate」を押すと、
    Drone／Soccer の最適組合せを一覧で表示します。  
    <br />
    ※Y は在庫に含めず、自動で補充されます。パーツ数が 6 未満の場合は、Drone≥Soccer となる 1 パターンだけを返却します。
  </p>

  <div class="parts-input">
    <div class="part-item">
      <img src="E.png" alt="E" /><br />
      <label>E</label><br />
      <input type="number" id="input-E" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L0.png" alt="L0" /><br />
      <label>L0</label><br />
      <input type="number" id="input-L0" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L1.png" alt="L1" /><br />
      <label>L1</label><br />
      <input type="number" id="input-L1" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L2.png" alt="L2" /><br />
      <label>L2</label><br />
      <input type="number" id="input-L2" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L3.png" alt="L3" /><br />
      <label>L3</label><br />
      <input type="number" id="input-L3" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L4.png" alt="L4" /><br />
      <label>L4</label><br />
      <input type="number" id="input-L4" min="0" value="0" />
    </div>
  </div>

  <div class="chip-input">
    <img src="chip_icon.png" alt="Chip" />
    <label>Chip 数:</label>
    <input type="number" id="input-chip" min="0" max="330" value="0" />
  </div>

  <button id="calculate-btn">Calculate</button>

  <div class="results-area">
    <h2>結果一覧</h2>
    <div id="results-container"></div>
  </div>

  <script>
    const partValues = { E:1000, L0:300, L1:400, L2:550, L3:700, L4:850, Y:200 };
    const targets = [900,1200,1650,2100,2550,3000,4500,6000,7500,9000,10500,12000,13500,15000];
    const allowedChips = [0, 1, 2, 4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90];
    let lookupTable = {};

    async function loadLookupTable() {
      const response = await fetch('Lookup_Table.csv');
      const csvText = await response.text();
      const lines = csvText.trim().split('\n');
      const header = lines[0].split(',').map(s => s.trim());
      const idxPartA = header.indexOf('PartA');
      const idxPartB = header.indexOf('PartB');
      const idxPartC = header.indexOf('PartC');
      const idxChip  = header.indexOf('Chip');
      const idxTotal = header.indexOf('Total');
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(',').map(s => s.trim());
        const pA = cols[idxPartA];
        const pB = cols[idxPartB];
        const pC = cols[idxPartC];
        const chip = parseInt(cols[idxChip], 10);
        const total = parseFloat(cols[idxTotal]);
        const partsKey = [pA, pB, pC].sort().join('|');
        if (!lookupTable[partsKey]) {
          lookupTable[partsKey] = {};
        }
        lookupTable[partsKey][chip] = total;
      }
    }

    window.addEventListener('DOMContentLoaded', async () => {
      await loadLookupTable();
      console.log('Lookup_Table.csv を読み込みました');
    });

    document.getElementById('calculate-btn').addEventListener('click', () => {
      const inv = {
        E:  parseInt(document.getElementById('input-E').value)  || 0,
        L0: parseInt(document.getElementById('input-L0').value) || 0,
        L1: parseInt(document.getElementById('input-L1').value) || 0,
        L2: parseInt(document.getElementById('input-L2').value) || 0,
        L3: parseInt(document.getElementById('input-L3').value) || 0,
        L4: parseInt(document.getElementById('input-L4').value) || 0
      };
      const C_total = parseInt(document.getElementById('input-chip').value) || 0;
      const N_parts = inv.E + inv.L0 + inv.L1 + inv.L2 + inv.L3 + inv.L4;
      let results;
      if (N_parts < 6) {
        results = computeUnderSix(inv, C_total);
      } else {
        results = computeOverOrEqualSix(inv, C_total);
      }
      renderResults(results);
    });

    function computeUnderSix(inventory, C_total) {
      const droneCombo = [];
      let tempInv = { ...inventory };
      for (let part of ['E','L0','L1','L2','L3','L4']) {
        while (tempInv[part] > 0 && droneCombo.length < 3) {
          droneCombo.push(part);
          tempInv[part]--;
        }
        if (droneCombo.length >= 3) break;
      }
      while (droneCombo.length < 3) {
        droneCombo.push('Y');
      }
      const soccerCombo = ['Y','Y','Y'];
      let c_d = 0;
      for (let c of allowedChips) {
        if (c <= C_total) c_d = c;
        else break;
      }
      const c_s = 0;
      const rem = C_total - c_d - c_s;
      const keyD = droneCombo.slice().sort().join('|');
      const keyS = soccerCombo.slice().sort().join('|');
      const totalD = (lookupTable[keyD] && lookupTable[keyD][c_d] !== undefined)
        ? lookupTable[keyD][c_d]
        : calculateOnTheFly(droneCombo, c_d);
      const totalS = (lookupTable[keyS] && lookupTable[keyS][c_s] !== undefined)
        ? lookupTable[keyS][c_s]
        : calculateOnTheFly(soccerCombo, c_s);
      const targetD = computeTargetFromTotal(totalD);
      const targetS = computeTargetFromTotal(totalS);
      return [{
        partsDrone: droneCombo,
        chipDrone: c_d,
        totalDrone: totalD,
        targetDrone: targetD,
        partsSoccer: soccerCombo,
        chipSoccer: c_s,
        totalSoccer: totalS,
        targetSoccer: targetS,
        chipRemainder: rem
      }];
    }

    function computeOverOrEqualSix(inventory, C_total) {
      const candidates = [];
      const droneCombos = enumerateCombosFromInventory(inventory, 3);
      for (let comboD of droneCombos) {
        const remInv = { ...inventory };
        comboD.forEach(p => remInv[p]--);
        const remCount = Object.values(remInv).reduce((sum, v) => sum + v, 0);
        let soccerCombos = [];
        if (remCount >= 3) {
          soccerCombos = enumerateCombosFromInventory(remInv, 3);
        } else {
          const thisCombo = [];
          for (let p of ['E','L0','L1','L2','L3','L4']) {
            while (remInv[p] > 0) {
              thisCombo.push(p);
              remInv[p]--;
            }
          }
          while (thisCombo.length < 3) {
            thisCombo.push('Y');
          }
          soccerCombos = [ thisCombo ];
        }
        for (let { cd, cs, rem } of generateChipSplits(C_total)) {
          const keyD = comboD.slice().sort().join('|');
          const totalD = (lookupTable[keyD] && lookupTable[keyD][cd] !== undefined)
            ? lookupTable[keyD][cd]
            : calculateOnTheFly(comboD, cd);
          for (let comboS of soccerCombos) {
            const keyS = comboS.slice().sort().join('|');
            const totalS = (lookupTable[keyS] && lookupTable[keyS][cs] !== undefined)
              ? lookupTable[keyS][cs]
              : calculateOnTheFly(comboS, cs);
            if (totalD < totalS) continue;
            const targetD = computeTargetFromTotal(totalD);
            const targetS = computeTargetFromTotal(totalS);
            candidates.push({
              partsDrone: comboD.slice(),
              chipDrone: cd,
              totalDrone: totalD,
              targetDrone: targetD,
              partsSoccer: comboS.slice(),
              chipSoccer: cs,
              totalSoccer: totalS,
              targetSoccer: targetS,
              chipRemainder: rem
            });
          }
        }
      }
      const paretoFiltered = paretoFilterByTarget(candidates);
      const finalResults = [];
      const groupByPair = {};
      for (let item of paretoFiltered) {
        const key = item.targetDrone + '|' + item.targetSoccer;
        if (!groupByPair[key]) groupByPair[key] = [];
        groupByPair[key].push(item);
      }
      for (let key in groupByPair) {
        const arr = groupByPair[key];
        let minRem = Math.min(...arr.map(o => o.chipRemainder));
        arr.filter(o => o.chipRemainder === minRem).forEach(o => finalResults.push(o));
      }
      finalResults.sort((a, b) => {
        if (a.targetDrone !== b.targetDrone) return a.targetDrone - b.targetDrone;
        if (a.targetSoccer !== b.targetSoccer) return a.targetSoccer - b.targetSoccer;
        return a.chipRemainder - b.chipRemainder;
      });
      return finalResults;
    }

    function enumerateCombosFromInventory(inventory, size) {
      const items = [];
      for (let p of ['E','L0','L1','L2','L3','L4']) {
        for (let i = 0; i < inventory[p]; i++) {
          items.push(p);
        }
      }
      const n = items.length;
      const results = [];
      function dfs(start, combo) {
        if (combo.length === size) {
          results.push(combo.slice());
          return;
        }
        for (let i = start; i < n; i++) {
          if (i > start && items[i] === items[i - 1]) continue;
          combo.push(items[i]);
          dfs(i + 1, combo);
          combo.pop();
        }
      }
      items.sort();
      dfs(0, []);
      return results;
    }

    function generateChipSplits(C_total) {
      const splits = [];
      for (let cd of allowedChips) {
        if (cd > C_total) break;
        for (let cs of allowedChips) {
          if (cd + cs > C_total) break;
          const rem = C_total - (cd + cs);
          splits.push({ cd, cs, rem });
        }
      }
      return splits;
    }

    function computeTargetFromTotal(total) {
      let t = 0;
      for (let val of targets) {
        if (total >= val) t = val;
        else break;
      }
      return t;
    }

    function paretoFilterByTarget(candidates) {
      const pairMap = {};
      for (let c of candidates) {
        const key = c.targetDrone + '|' + c.targetSoccer;
        if (!pairMap[key]) pairMap[key] = [];
        pairMap[key].push(c);
      }
      const pairKeys = Object.keys(pairMap);
      const pairList = pairKeys.map(k => {
        const [td, ts] = k.split('|').map(x => parseInt(x, 10));
        return { td, ts, key: k };
      });
      pairList.sort((a, b) => {
        if (a.td !== b.td) return a.td - b.td;
        return a.ts - b.ts;
      });
      const nonDominatedKeys = new Set(pairList.map(o => o.key));
      for (let i = 0; i < pairList.length; i++) {
        const { td: td_i, ts: ts_i, key: key_i } = pairList[i];
        for (let j = i + 1; j < pairList.length; j++) {
          const { td: td_j, ts: ts_j, key: key_j } = pairList[j];
          if (td_j > td_i && ts_j > ts_i) {
            nonDominatedKeys.delete(key_i);
            break;
          }
        }
      }
      const filtered = [];
      for (let key of nonDominatedKeys) {
        filtered.push(...pairMap[key]);
      }
      return filtered;
    }

    function calculateOnTheFly(comboParts, chip) {
      let baseSum = 0;
      for (let p of comboParts) {
        baseSum += partValues[p];
      }
      const multMap = {
        0:1.0,   1:1.2,  2:1.4,  4:1.6,  6:1.8,
        9:2.0,  12:2.2, 16:2.4, 20:2.6, 25:2.8,
        30:3.0, 36:3.2, 42:3.4, 48:3.6, 54:3.8,
        60:4.0, 66:4.2, 72:4.4, 78:4.6, 84:4.8,
        90:5.0
      };
      const m = multMap[chip] !== undefined ? multMap[chip] : 1.0;
      return baseSum * m;
    }

    function renderResults(results) {
      const container = document.getElementById('results-container');
      container.innerHTML = '';
      if (!results || results.length === 0) {
        container.innerHTML = '<p>該当する組み合わせはありませんでした。</p>';
        return;
      }
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const headers = [
        'Drone パーツ', 'Chip_D', 'Total_D', 'Target_D',
        'Soccer パーツ', 'Chip_S', 'Total_S', 'Target_S',
        '余りChip'
      ];
      for (let h of headers) {
        const th = document.createElement('th');
        th.textContent = h;
        headerRow.appendChild(th);
      }
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for (let item of results) {
        const tr = document.createElement('tr');
        const cells = [
          item.partsDrone.join(', '),
          item.chipDrone,
          item.totalDrone.toFixed(0),
          item.targetDrone,
          item.partsSoccer.join(', '),
          item.chipSoccer,
          item.totalSoccer.toFixed(0),
          item.targetSoccer,
          item.chipRemainder
        ];
        for (let c of cells) {
          const td = document.createElement('td');
          td.textContent = c;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      container.appendChild(table);
    }
  </script>
</body>
</html>
