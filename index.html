<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>パーツ＋チップ最適化計算ツール</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1 { text-align: center; }
    .parts-input { display: flex; flex-wrap: wrap; gap: 12px; }
    .part-item { text-align: center; width: 100px; }
    .part-item img { width: 60px; height: 60px; }
    .part-item input[type="number"] { width: 60px; margin-top: 4px; }
    .chip-input { margin-top: 16px; text-align: center; }
    .chip-input img { vertical-align: middle; width: 40px; height: 40px; }
    #calculate-btn { margin-top: 20px; display: block; padding: 8px 16px; font-size: 16px; }
    .results-area { margin-top: 30px; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: center; }
  </style>
</head>
<body>

  <h1>パーツ＋チップ 最適化計算ツール</h1>
  <p>
    以下に所持パーツの枚数と Chip の数を入力し、「Calculate」を押すと、
    Drone／Soccer の最適組合せを一覧で表示します。  
    <br />
    ※Y は在庫に含めず、自動で補充されます。パーツ数が 6 未満の場合は、Drone≥Soccer となる 1 パターンだけを返却します。
  </p>

  <!-- パーツ入力欄（E, L0〜L4） -->
  <div class="parts-input">
    <div class="part-item">
      <img src="E.png" alt="E" /><br />
      <label>E</label><br />
      <input type="number" id="input-E" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L0.png" alt="L0" /><br />
      <label>L0</label><br />
      <input type="number" id="input-L0" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L1.png" alt="L1" /><br />
      <label>L1</label><br />
      <input type="number" id="input-L1" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L2.png" alt="L2" /><br />
      <label>L2</label><br />
      <input type="number" id="input-L2" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L3.png" alt="L3" /><br />
      <label>L3</label><br />
      <input type="number" id="input-L3" min="0" value="0" />
    </div>
    <div class="part-item">
      <img src="L4.png" alt="L4" /><br />
      <label>L4</label><br />
      <input type="number" id="input-L4" min="0" value="0" />
    </div>
  </div>

  <!-- Chip 入力欄 -->
  <div class="chip-input">
    <img src="chip_icon.png" alt="Chip" />
    <label>Chip 数:</label>
    <input type="number" id="input-chip" min="0" max="330" value="0" />
  </div>

  <!-- 計算ボタン -->
  <button id="calculate-btn">Calculate</button>

  <!-- 結果表示エリア -->
  <div class="results-area">
    <h2>結果一覧</h2>
    <div id="results-container"></div>
  </div>

  <script>
    // 【定数・マッピング】
    const partValues = { E:1000, L0:300, L1:400, L2:550, L3:700, L4:850, Y:200 };
    const targets = [900,1200,1650,2100,2550,3000,4500,6000,7500,9000,10500,12000,13500,15000];
    const allowedChips = [0, 1, 2, 4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90];
    let lookupTable = {};  // { "P1|P2|P3": { chip: total, ... }, ... }

    // ── 事前処理：Lookup_Table.csv 読み込み ──
    async function loadLookupTable() {
      const response = await fetch('Lookup_Table.csv');
      const csvText = await response.text();
      const lines = csvText.trim().split('\\n');
      const header = lines[0].split(',').map(s => s.trim());
      const idxA = header.indexOf('Const1');
      const idxB = header.indexOf('Const2');
      const idxC = header.indexOf('Const3');
      const idxChip = header.indexOf('Chip');
      const idxTotal = header.indexOf('Total');
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(',').map(s => s.trim());
        const pA = cols[idxA], pB = cols[idxB], pC = cols[idxC];
        const chip = parseInt(cols[idxChip], 10);
        const total = parseFloat(cols[idxTotal]);
        const key = [pA, pB, pC].sort().join('|');
        if (!lookupTable[key]) lookupTable[key] = {};
        lookupTable[key][chip] = total;
      }
    }
    window.addEventListener('DOMContentLoaded', async () => {
      await loadLookupTable();
      console.log('Lookup_Table.csv を読み込みました');
    });

    // ── Calculate ボタン押下時 ──
    document.getElementById('calculate-btn').addEventListener('click', () => {
      const inv = {
        E:  parseInt(document.getElementById('input-E').value)  || 0,
        L0: parseInt(document.getElementById('input-L0').value) || 0,
        L1: parseInt(document.getElementById('input-L1').value) || 0,
        L2: parseInt(document.getElementById('input-L2').value) || 0,
        L3: parseInt(document.getElementById('input-L3').value) || 0,
        L4: parseInt(document.getElementById('input-L4').value) || 0
      };
      const C_total = parseInt(document.getElementById('input-chip').value) || 0;
      const N_parts = inv.E + inv.L0 + inv.L1 + inv.L2 + inv.L3 + inv.L4;

      let results;
      if (N_parts < 6) {
        results = computeUnderSix(inv, C_total);
      } else {
        results = computeOverOrEqualSix(inv, C_total);
      }

      renderResults(results);
    });

    // ── 関数：N_parts < 6 の場合 ──
    function computeUnderSix(inventory, C_total) {
      // 1) Drone 用：在庫から順に３枚取る（残りは Y で補完）
      const droneCombo = [];
      let tempInv = { ...inventory };
      for (let p of ['E','L0','L1','L2','L3','L4']) {
        while (tempInv[p] > 0 && droneCombo.length < 3) {
          droneCombo.push(p);
          tempInv[p]--;
        }
        if (droneCombo.length >= 3) break;
      }
      while (droneCombo.length < 3) { droneCombo.push('Y'); }

      // 2) Soccer 用：常に ['Y','Y','Y']
      const soccerCombo = ['Y','Y','Y'];

      // 3) Chip：Drone に allowedChips のうち ≤ C_total の最大値を割り当て、Soccer=0
      let c_d = 0;
      for (let c of allowedChips) {
        if (c <= C_total) c_d = c;
        else break;
      }
      const c_s = 0;
      const rem = C_total - c_d - c_s;

      // 4) Total, Target を計算
      const keyD = droneCombo.slice().sort().join('|');
      const keyS = soccerCombo.slice().sort().join('|');
      const totalD = (lookupTable[keyD] && lookupTable[keyD][c_d] !== undefined)
        ? lookupTable[keyD][c_d]
        : calculateOnTheFly(droneCombo, c_d);
      const totalS = (lookupTable[keyS] && lookupTable[keyS][c_s] !== undefined)
        ? lookupTable[keyS][c_s]
        : calculateOnTheFly(soccerCombo, c_s);
      const targetD = computeTargetFromTotal(totalD);
      const targetS = computeTargetFromTotal(totalS);

      return [{
        partsDrone: droneCombo,
        chipDrone: c_d,
        totalDrone: totalD,
        targetDrone: targetD,
        partsSoccer: soccerCombo,
        chipSoccer: c_s,
        totalSoccer: totalS,
        targetSoccer: targetS,
        chipRemainder: rem
      }];
    }

    // ── 関数：N_parts ≥ 6 の場合 ──
    function computeOverOrEqualSix(inventory, C_total) {
      const candidates = [];
      // 1) Drone 用 3 枚組み合わせをすべて列挙
      const droneCombos = enumerateCombosFromInventory(inventory, 3);

      for (let comboD of droneCombos) {
        // 1-1) 残在庫を計算して Soccer 組み合わせを列挙
        const remInv = { ...inventory };
        comboD.forEach(p => remInv[p]--);
        const remCount = Object.values(remInv).reduce((sum, v) => sum + v, 0);

        let soccerCombos = [];
        if (remCount >= 3) {
          soccerCombos = enumerateCombosFromInventory(remInv, 3);
        } else {
          const thisCombo = [];
          for (let p of ['E','L0','L1','L2','L3','L4']) {
            while (remInv[p] > 0) {
              thisCombo.push(p);
              remInv[p]--;
            }
          }
          while (thisCombo.length < 3) { thisCombo.push('Y'); }
          soccerCombos = [ thisCombo ];
        }

        // 2) Chip のすべての分割パターンを試す
        for (let { cd, cs, rem } of generateChipSplits(C_total)) {
          // 2-1) Drone 側 Total, Target
          const keyD = comboD.slice().sort().join('|');
          const totalD = (lookupTable[keyD] && lookupTable[keyD][cd] !== undefined)
            ? lookupTable[keyD][cd]
            : calculateOnTheFly(comboD, cd);

          // 2-2) 各 Soccer パターンをループ
          for (let comboS of soccerCombos) {
            const keyS = comboS.slice().sort().join('|');
            const totalS = (lookupTable[keyS] && lookupTable[keyS][cs] !== undefined)
              ? lookupTable[keyS][cs]
              : calculateOnTheFly(comboS, cs);

            // 「Total_D < Total_S」なら不適合
            if (totalD < totalS) continue;

            const targetD = computeTargetFromTotal(totalD);
            const targetS = computeTargetFromTotal(totalS);

            candidates.push({
              partsDrone: comboD.slice(),
              chipDrone: cd,
              totalDrone: totalD,
              targetDrone: targetD,
              partsSoccer: comboS.slice(),
              chipSoccer: cs,
              totalSoccer: totalS,
              targetSoccer: targetS,
              chipRemainder: rem
            });
          }
        }
      }

      // 3) ドミナンス排除（targetD, targetS の両方で優劣を見て不要なペアを除去）
      const paretoFiltered = paretoFilterByTarget(candidates);

      // 4) 最終フィルタリング：<targetD ごと>に「最大の targetS → 最小 rem → 最小 totalD → 最小 totalS」
      const finalResults = [];
      const groupByTD = {};
      for (let item of paretoFiltered) {
        const td = item.targetDrone;
        if (!groupByTD[td]) groupByTD[td] = [];
        groupByTD[td].push(item);
      }
      for (let td in groupByTD) {
        const itemsTD = groupByTD[td];
        const maxTS = Math.max(...itemsTD.map(o => o.targetSoccer));
        const itemsTS = itemsTD.filter(o => o.targetSoccer === maxTS);

        const minRem = Math.min(...itemsTS.map(o => o.chipRemainder));
        const itemsRem = itemsTS.filter(o => o.chipRemainder === minRem);

        const minTotalD = Math.min(...itemsRem.map(o => o.totalDrone));
        const itemsTD2 = itemsRem.filter(o => o.totalDrone === minTotalD);

        const minTotalS = Math.min(...itemsTD2.map(o => o.totalSoccer));
        const finalItems = itemsTD2.filter(o => o.totalSoccer === minTotalS);

        finalResults.push(...finalItems);
      }

      // 5) targetD の昇順ソート
      finalResults.sort((a, b) => a.targetDrone - b.targetDrone);
      return finalResults;
    }

    // ────────────────
    // ヘルパー関数群
    // ────────────────

    // ＜ヘルパー1＞ 在庫から “重複可・順不同で size 枚” を列挙
    function enumerateCombosFromInventory(inventory, size) {
      const items = [];
      for (let p of ['E','L0','L1','L2','L3','L4']) {
        for (let i = 0; i < inventory[p]; i++) {
          items.push(p);
        }
      }
      items.sort();
      const n = items.length;
      const results = [];
      function dfs(start, combo) {
        if (combo.length === size) {
          results.push(combo.slice());
          return;
        }
        for (let i = start; i < n; i++) {
          if (i > start && items[i] === items[i - 1]) continue;
          combo.push(items[i]);
          dfs(i + 1, combo);
          combo.pop();
        }
      }
      dfs(0, []);
      return results;
    }

    // ＜ヘルパー2＞ Chip 分割パターンを列挙
    function generateChipSplits(C_total) {
      const splits = [];
      for (let cd of allowedChips) {
        if (cd > C_total) break;
        for (let cs of allowedChips) {
          if (cd + cs > C_total) break;
          const rem = C_total - (cd + cs);
          splits.push({ cd, cs, rem });
        }
      }
      return splits;
    }

    // ＜ヘルパー3＞ Total から Target を算出（Total < 900 → 0）
    function computeTargetFromTotal(total) {
      let t = 0;
      for (let val of targets) {
        if (total >= val) t = val;
        else break;
      }
      return t;
    }

    // ＜ヘルパー4＞ ドミナンス排除： (targetD, targetS) ベースで不要なペアを除去
    function paretoFilterByTarget(candidates) {
      const pairMap = {};
      for (let c of candidates) {
        const key = c.targetDrone + '|' + c.targetSoccer;
        if (!pairMap[key]) pairMap[key] = [];
        pairMap[key].push(c);
      }
      const pairList = [];
      for (let key in pairMap) {
        const [td, ts] = key.split('|').map(x => parseInt(x, 10));
        pairList.push({ td, ts, key });
      }
      pairList.sort((a, b) => a.td - b.td || a.ts - b.ts);
      const nonDominatedKeys = new Set(pairList.map(o => o.key));
      for (let i = 0; i < pairList.length; i++) {
        const { td: td_i, ts: ts_i, key: key_i } = pairList[i];
        for (let j = i + 1; j < pairList.length; j++) {
          const { td: td_j, ts: ts_j, key: key_j } = pairList[j];
          if (td_j > td_i && ts_j > ts_i) {
            nonDominatedKeys.delete(key_i);
            break;
          }
        }
      }
      const filtered = [];
      for (let key of nonDominatedKeys) {
        filtered.push(...pairMap[key]);
      }
      return filtered;
    }

    // ＜ヘルパー5＞ CSV にない場合のオンザフライ計算
    function calculateOnTheFly(comboParts, chip) {
      let baseSum = 0;
      for (let p of comboParts) { baseSum += partValues[p]; }
      const multMap = {
        0:1.0,  1:1.2,  2:1.4,  4:1.6,  6:1.8,
        9:2.0, 12:2.2, 16:2.4, 20:2.6, 25:2.8,
        30:3.0,36:3.2,42:3.4,48:3.6,54:3.8,
        60:4.0,66:4.2,72:4.4,78:4.6,84:4.8,
        90:5.0
      };
      const m = multMap[chip] !== undefined ? multMap[chip] : 1.0;
      return baseSum * m;
    }

    // ＜ヘルパー6＞ 結果をテーブル表示
    function renderResults(results) {
      const container = document.getElementById('results-container');
      container.innerHTML = '';
      if (!results || results.length === 0) {
        container.innerHTML = '<p>該当する組み合わせはありませんでした。</p>';
        return;
      }
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const headers = [
        'Drone パーツ', 'Chip_D', 'Total_D', 'Target_D',
        'Soccer パーツ', 'Chip_S', 'Total_S', 'Target_S',
        '余りChip'
      ];
      for (let h of headers) {
        const th = document.createElement('th');
        th.textContent = h;
        headerRow.appendChild(th);
      }
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for (let item of results) {
        const tr = document.createElement('tr');
        const cells = [
          item.partsDrone.join(', '),
          item.chipDrone,
          item.totalDrone.toFixed(0),
          item.targetDrone,
          item.partsSoccer.join(', '),
          item.chipSoccer,
          item.totalSoccer.toFixed(0),
          item.targetSoccer,
          item.chipRemainder
        ];
        for (let c of cells) {
          const td = document.createElement('td');
          td.textContent = c;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      container.appendChild(table);
    }
  </script>

</body>
</html>
